{"meta":{"title":"One_Lab","subtitle":"Study","description":null,"author":"Soo","url":"http://onemask.github.io"},"pages":[{"title":"18_07_25","date":"2018-07-25T13:01:59.000Z","updated":"2018-07-25T13:01:59.682Z","comments":true,"path":"18-07-25/index.html","permalink":"http://onemask.github.io/18-07-25/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-07-25T13:03:26.000Z","updated":"2018-07-25T13:04:18.014Z","comments":true,"path":"categories/index.html","permalink":"http://onemask.github.io/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-08-03T05:05:49.000Z","updated":"2018-08-03T05:07:14.893Z","comments":true,"path":"tags/index.html","permalink":"http://onemask.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[Koltin]Exception","slug":"Koltin-Exception","date":"2018-08-29T04:46:18.000Z","updated":"2018-08-29T04:46:18.669Z","comments":true,"path":"2018/08/29/Koltin-Exception/","link":"","permalink":"http://onemask.github.io/2018/08/29/Koltin-Exception/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"[Java] 접근 제어자 Access modifier","slug":"Access-modifier","date":"2018-08-22T12:13:32.000Z","updated":"2018-08-27T07:40:08.913Z","comments":true,"path":"2018/08/22/Access-modifier/","link":"","permalink":"http://onemask.github.io/2018/08/22/Access-modifier/","excerpt":"","text":"Kotlin을 공부하다가 access modifier를 정확하게 인지하고자 글을 쓰기로 했다.","categories":[],"tags":[]},{"title":"[Kotlin]Array","slug":"Kotlin-Array","date":"2018-08-22T11:27:06.000Z","updated":"2018-08-22T13:09:30.822Z","comments":true,"path":"2018/08/22/Kotlin-Array/","link":"","permalink":"http://onemask.github.io/2018/08/22/Kotlin-Array/","excerpt":"","text":"123456789101112131415161718192021222324252627282930/* * Chapt 60 :Array[] 사용하기. */class Person(var name:String,var birthday:String) &#123; // Operator : 오버로딩 키워드. 1 operator fun get(position: Int): String &#123; return when (position) &#123; 0 -&gt; name 1 -&gt; birthday else -&gt; \"알수 없음\" &#125; &#125; // Operator : 오버로딩 키워드. 2 operator fun get(position: Int, value: String) &#123; when (position) &#123; 0 -&gt; name = value 1 -&gt; birthday = value &#125; &#125;&#125; fun main(args: Array&lt;String&gt;)&#123; val person = Person(\"Kotlin\",\"2018-08-22\") println(person[0]) // operator 1 수행. println(person[1]) println(person[-1]) //person[0]=\"java\" println(person.name) &#125; ##When kotlin에서 when 키워드는 switch 문과 같다. 12345678910package Operatorclass Product (val id:Int, val name:String)&#123; operator fun invoke (value: Int)&#123; println(value) println(\"id : $id\\nname: $name \") &#125;&#125; 1234fun main(args : Array&lt;String&gt;)&#123; val product = Product(123456, \"김수연\") //println(\"id : $id\\nname: $name \")출력 product(108) //println(value) 출력&#125; 12345678910/* * Chapt 62 : in 연산자 */ fun main(args : Array&lt;String&gt;)&#123; println('o' in \"Kotlin\") println ('수' in \"김수연\") &#125; in in 연산자는 컴파일시 Kotlin.contains(‘o’)로 번역된다.결과값은 true,false 로 Boolean 타입이다. 12345678910111213141516/* * Chapt 63 : 멤버 함수의 중위 표기법. */ class Point(var x : Int, var y: Int)&#123; infix fun from(base : Point) : Point&#123; return Point(x-base.x,y-base.y) &#125; &#125; fun main(args : Array&lt;String&gt;)&#123; val pt = Point(3,6)from Point(1,1) //중위표기법 println(pt.x) //2 println(pt.y) //5 &#125; 중위 표기법- infix 피연산자 연산자 피연산자 의 순서로 표현식을 정의한다. ex) Point(6,2 )- Point( 1,1) 함수 선언문 앞에 inifx를 붙여야 한다. 1234567891011121314package inheritance/* * 64 상속 */open class Person(val name: String,val age: Int)class Student (name :String,age : Int,val country : String) : Person(name,age)fun main (args:Array&lt;String&gt;)&#123; var peron = Person(\"도라에몽\",200) var student = Student(\"진구\",18,\"Japan\")&#125; name과 age 프로피터를 갖는 클래스 생성,-&gt; Person (슈퍼클래스)이 클래스를 상속하여 새로운 클래스 정의 -&gt; Student (서브클래스) 서브클래스 앞에 super을 붙이면 슈퍼클래스가 된다. 즉 슈퍼클래스와 서브 클래스 둘다 가능하다. 그러나 서브 클래스는 2개 이상의 클래스는 동시에 상속이 불가능하다. Kotlin에서 클래스는 Final로 선언되어 있어 상속이 불가능하다.상속을 허용하려면 open 키워드를 붙여줘야한다. []: //접근 제어자 Person 인스턴스 생성Student 인스턴스 생성중.@ 메모리구조 그림 삽입. 오버라이딩슈퍼클래스의 멤버 함수와 동일한 멤버 함수를 서브 클래스에 선언하면, 슈퍼클래스 멤버 함수의 동작을 덮어쓸 수 있다. 1234567891011121314151617package Overridingopen class AAA&#123; //Super Class open fun func()= println(\"AAA\") //오버라이딩 함수를 가능케 하기 위한 open 키워드 &#125;class BBB : AAA()&#123; //AAA클래스를 상속한다. override fun func()&#123; //오버라이딩을 위하여 override 키워드 붙이기. super.func() //AAA.func 호출. println(\"BBB\") &#125;&#125;fun main (args:Array&lt;String&gt;)&#123; AAA().func() BBB().func()&#125; this 클래스가 자기 자신의 이름을 나타낸다면,super 클래스는 super 클래스의 이름을 나타낸다. 출력은 아래와 같다.","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://onemask.github.io/tags/Kotlin/"}]},{"title":"[Kotlin]Constructor","slug":"Kotlin-Constructor","date":"2018-08-16T10:30:19.000Z","updated":"2018-08-16T11:50:46.592Z","comments":true,"path":"2018/08/16/Kotlin-Constructor/","link":"","permalink":"http://onemask.github.io/2018/08/16/Kotlin-Constructor/","excerpt":"","text":"12345678910111213package ex_packageimport ex_func.*// Chapt 56. 생성자와 매개벼수를 같이 선언해서 사용.class Car (val name : String,val speed: Int =0)fun main(args: Array&lt;String&gt;)&#123; val car = Car(\"My Car\") println(car.name) println(car.speed)&#125; 12345678910111213141516171819202122232425262728293031323334package ex_packageimport ex_func.*// Chapt 57. 주생성자.class Time constructor(val second: Int /*매개변수*/) &#123; init &#123; println(\"init 블록 실행중 \") &#125; //보조 생성자1 constructor(minuate: Int, second: Int) : this(minuate * 60 + second) &#123; println(\"보조 생성자 1실행 중 \") &#125; //보조 생성자 2 constructor(hour: Int, minuate: Int, second: Int) : this(hour * 60 + minuate, +second) &#123; println(\"보조 생성자 2실행 중 \") &#125; init &#123; println(\"또 다른 init 블록 실행 중 \") &#125;&#125;fun main (args: Array&lt;String&gt;)&#123; //println(\"$&#123;Time(15,6).second&#125;초\") println(\"$&#123;Time(6,3,17).second&#125;초\")&#125;/* 클래스에 주생성자가 존재한다면 주 생성자를 반드시 먼저 호출해줘야한다. * this이 클래스에 포함된 또 다른 생성자를 호출하는 문법 */ This 키워드는 클래스 이름을 나타내는 대명사라고 생각하면된다. 1234567891011121314151617181920212223package ex_packageimport ex_func.*// Chapt 58. 프로퍼티 Geter와 Setter.class Person&#123; var age : Int =0 get() &#123; return field // 데이터가 저장되는 공간(Field), 여기서는 age인듯? // 프로퍼티 속 변수에 저장된 값을 반환한다. &#125; set(value) &#123; field = if(value &gt;=0 )value else 0 &#125;&#125;fun main(args:Array&lt;String&gt;)&#123; val person = Person() person.age = 29 //person.age에 프로퍼티에 값을 대입하면, setter가 호출된다. println(person.age) //person.age 값을 읽어오려면 ,getter가 호출된다. &#125; Field : 데이터가 저장되는 공간 Getter: 저장된 값을 읽을때 호출되는 함수 Setter : 값을 저장하려고 할 떄 호출되는 함수. TIP) val 프로피터는 초기 값이 주어지면 더 이상 값을 변경(set)할 수 없다. 그래서 val 프로피터에는 Getter만 존재한다. val 프로피터에 Setter을 정의하려고 하면 오류 발생 ! var age =0 / get / set [Kotlin] Chapt 56~ 59","categories":[],"tags":[]},{"title":"[kotlin]스택&힙 메모리","slug":"kotlin-스택-힙-메모리","date":"2018-08-03T05:52:52.000Z","updated":"2018-08-22T12:26:16.088Z","comments":true,"path":"2018/08/03/kotlin-스택-힙-메모리/","link":"","permalink":"http://onemask.github.io/2018/08/03/kotlin-스택-힙-메모리/","excerpt":"","text":"[Kotlin] 메모리 구조.면접에서 메모리 구조 물어봤을때 많이 당황했다..변수가 저장되는 메모리구조에 대하여 알아놓자! 메모리의 스택 영역 - 지역변수가 저장. 12345678910111213141516/*** * 40_ 메모리의 스택영역. */fun main(args: Array&lt;String&gt;)&#123; val a = -36 val result = Absolute(a) println(a)&#125;//입력 받는 정수의 절대값을 반환하는 함수fun Absolute(number: Int):Int&#123; return if(number &gt;=0) number else -number &#125; 스택영역 main() args a result Absolute() number 스택의 특성상 한개씩 pop 하는 성질에 따라서 가장 나중에 들어온 number값 popAbsolute() popa popargs popmain pop 모든 main 함수가 끝나면 result 값 출력. 메모리의 힙 영역 - 객체가 만들어지는 공간. (object나 class 같은. ) 12345678fun main(args:Array&lt;String&gt;)&#123; val person = object &#123; //person 변수에 object 선언 동시 초기화. val name:String = \"홍길동\" val age :Int = 23 &#125; println(person.name) println(person.age)&#125; 스택 영역 main() args person &lt;스택 영역&gt; &lt;힙 영역&gt;person( 스택 영역) -&gt; person.name -&gt; person.age object 표현은 힙 영역에 객체를 생성하며 객체의 좌표값을 갖는다.person 변수에는 객체의 좌표값을 저장하기 위한 공간만 존재한다. 실제 값을 가지고 있지 않지만 좌표만 저장하는 변수를 참조변수라 한다.객체의 좌표값은 참조값이라 부른다. 왜 이렇게 스택 영역과 힙 영역으로 메모리 구조를 나누어 놓았을까? *힙 영역의 존재 이유1234class Product&#123; var name=\"\" var price =0&#125; 123456789101112131415161718192021222324fun main(args:Array&lt;String&gt;)&#123; val product : Product product = createProduct() printProductInfo(product) processProduct(product) printProductInfo(product)&#125;fun createProduct(): Product &#123; val apple= Product() apple.name= \"Apple\" apple.price =1000 return apple&#125;fun processProduct(product: Product)&#123; product.price +=500&#125;fun printProductInfo(product: Product)&#123; println(\"이름 $&#123;product.name&#125;\") println(\"가격 $&#123;product.price&#125;\")&#125; 스택영역 | main() | args || :————– | ————– || | product || createProduct() | apple-&gt; 힙영역 | 힙 영역 name price “” 0 name price “apple” 1000 스택 영역 | main() | args || ———————- | ———————————————————— || | product-&gt; 힙 영역 || createProduct() | apple-&gt; 힙영역 || printProductInfo() | product-&gt;힙 영역name: Appleprice: 1000 || processProduct() | product-&gt;힙 영역price: 1000 + 500 = 1500 || printProductInfo() | product-&gt;힙 영역name: Appleprice: 1500 | 스택 영역에서 createProduct()는 함수는 사라지지만 apple 참조 변수가 가리키고 있던객체는 힙에서 사라지지 않는다. main()에 product 변수도 힙 영역을 가르키고printProductInfo() product 변수도 힙 영역을 가르키고 있다. 힙 영역이 없었다면 각각 자신만의 name과 price 변수를 가지고 있을것이다.이처럼 힙 영역을 두면 하나의 객체를 여러 참조 변수에서 공유하는 형태로 사용하여메모리 공간을 절약할수 있다.","categories":[],"tags":[]},{"title":"[Kotlin]클래스","slug":"Kotlin-클래스","date":"2018-08-03T05:43:58.000Z","updated":"2018-08-03T05:44:36.457Z","comments":true,"path":"2018/08/03/Kotlin-클래스/","link":"","permalink":"http://onemask.github.io/2018/08/03/Kotlin-클래스/","excerpt":"","text":"클래스 (Class) 객체를 찍어내는 틀. 12345678910111213141516package ex_packageval person = object &#123; val name :String =\"심슨\" val age : Int = 45&#125;val person2 = object&#123; val name : String = \"마지 \" val age : Int = 40&#125;val person3 = object&#123; val name: String = \"아들심슨\" val age : Int = 15&#125; 객체를 하나하나 선언해주고 초기화 해줘야함. 세상 귀찮음.. 클래스를 이용한다면? / 클래스 선언하기 / 1234class Person &#123; //클래스 이름. var name : String = \"\" // 속성~ var age : Int = 0&#125; 1234567891011121314151617fun main (args: Array&lt;String&gt;)&#123; val person1 : Person person1 = Person() person1.name = \"심슨\" person1.age = 45 val person2 : Person person2 = Person() person2.name = \"머지\" person2.age = 40 val person3 : Person person3 = Person() person3.name = \"아들심슨\" person3.age = 15&#125; val 객체 명 : class 명. 변수의 타입으로 지정해 놓은 class 명이 들어간다. Java클래스 선언 Kotlin 클래스 선언 클래스 이름 = 파일 이름 클래스 이름 != 파일 이름 클래스 파일과 : 클래스 선언 = 1:1 클래스 파일: 클래스 선언 = 1:n ++ Kotlin 객체 생성할때 new 키워드가 사라졌다 !! 클래스로로 부터 생성된 객체는 인스턴스라고 부른다. 위의 코드에서는 person 1,2,3가 그렇다. 이러한 객체를 인스턴스라고 부른다.틀로부터 구체적으로 만들어 지기 때문이디ㅏ. ++ Kotlin은 default 값이 Public","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://onemask.github.io/tags/Kotlin/"}]},{"title":"[Koltin] 객체 ","slug":"Koltin-객체","date":"2018-08-02T11:32:56.000Z","updated":"2018-08-02T11:33:49.493Z","comments":true,"path":"2018/08/02/Koltin-객체/","link":"","permalink":"http://onemask.github.io/2018/08/02/Koltin-객체/","excerpt":"","text":"[Kotlin] 객체.: 서로 연관 있는 변수 들을 묶어 놓는 데이터 덩어리. 1234567891011package ex_objectfun main(args:Array&lt;String&gt;)&#123; val person = object &#123; val name:String = \"홍길동\" val age :Int = 23 &#125; println(person.name) println(person.age)&#125; Koltin에서 Property_속성 (name,age) -&gt; 선언과 동시에 초기화해야한다. #자바의 Field &amp; 코틀린의 Property 자바는 객체 지향형 프로그램이기에 데이터 자체는 외부에서 접근할 수 없도록 private 접근 제어자로 설정하고 public 으로 메소드만 공개하고 이 중 유효한 값들을 데이터로 저장한다. private로 설정한 속성이 자바의 Field 이다. 이러한 Field 와 Setter(값을 설정), Getter(값 가져오기)를 합친 개념이코틀린의 Property다. 123456789101112131415161718public class Person&#123; private String name; private int age;&#125;public String setName(String name)&#123; this.name= n;&#125;public String getName()&#123; return name;&#125;public String setAge(int age)&#123; this.age= age;&#125;public String setName(String n)&#123; return age;&#125; 참고 서적 : 초보자를 위한 Koltin 200제.","categories":[],"tags":[]},{"title":"[Java]백준알고리즘_2750_수 정렬하기","slug":"백준알고리즘-2750","date":"2018-08-02T07:27:45.000Z","updated":"2018-08-08T05:50:36.860Z","comments":true,"path":"2018/08/02/백준알고리즘-2750/","link":"","permalink":"http://onemask.github.io/2018/08/02/백준알고리즘-2750/","excerpt":"","text":"[Back_2750]수 정렬하기. 알고리즘 분류로 2750 문제를 보면 삽입 정렬과 버블정렬 2가지 방식으로 풀기를 권하고 있다. 보자마자 어떻게 짜야할지는 감이 왔다. Java를 사용하는 나로써는 Test_case만큼 입력받고해당 크기에 해당하는 배열을 만들어서 오름차순으로 정렬하고자 했다.그래서 작성한 코드는 아래와 같다. 12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;public class Back_2750 &#123; public static void main(String[]args)&#123; Scanner sc = new Scanner(System.in); int caseNum = sc.nextInt(); int[] array = new int[caseNum]; for (int i=0;i&lt;caseNum;i++) array[i]=sc.nextInt(); solution(array); for (int i=0;i&lt;array.length;i++) System.out.println(array[i]); &#125; private static void solution(int[] array) &#123; for (int i=0;i&lt;array.length;i++)&#123; for(int j=i;j&lt;array.length;j++) &#123; if (array[i] &gt; array[j]) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; &#125; &#125;&#125; 메모리는 16920KB 정도 차지했고버블 정렬을 이용했다. 버블 정렬 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘.ex) [ 5, 4, 3, 2, 1] -&gt; 5와 4를 비교하고 큰 값을 오른쪽으로[ 4, 5, 3, 2, 1] -&gt; 5,3 을 비교하고 큰 값을 오른쪽으로 [4, 3 ,5 ,2 , 1] -&gt; 5,2 비교 [4, 3 ,2 ,5, 1] -&gt; 5,1 비교 [4, 3, 2, 1, 5] - &gt; 이렇게 배열의 크기만큼 한 번 돌고나면 가장 큰 수가 맨 오른쪽에 위치한다. 그 다음 가장 큰 자리수를 제외한 [4,3,2,1,5 ] -&gt; 5는 고정, 4~1 까지를 비교한다. 4,3 비교 [3,4,2,1,5] -&gt; 5는 고정, 4,2 비교. [3, 2, 4, 1, 5]-&gt; 5는 고정,4,1 비교 [3, 2, 1, 4, 5 ]- &gt; 2번쨰로 큰 4자리 찾는다. 이렇게 총 4번, 3번, 2번,1번 교환이 이루어진다. n-1,n-2,….,2,1 = n(n-1)/2 버블 정렬의 시간 복잡도 Best : N^2 Avg : N^2 Worst : N^2 정렬이 되어있든 안 되었있든 모든 배열의 n-1만큼 탐색을 해야하기에 Best, Avg, Worst 모두 동일하게 N^2 걸린다. 단순한만큼 비효율적인 방법이라고 한다. 세상에나 내가 여태 짯던 알고리즘은 선택정렬이였어;;멤붕. 버블정렬 알고리즘은 아래와 같다. 123456789101112private static void buble_sort(int[] array)&#123; for (int i=array.length-1;i&gt;0;i--)&#123; //0~array.length-1 만큼 반복 for(int j=0;j&lt;i;j++)&#123; if(array[j]&gt;array[j+1])&#123; int temp= array[j]; array[j]= array[j+1]; array[j+1] = temp; &#125; &#125; &#125;&#125;","categories":[],"tags":[]}]}